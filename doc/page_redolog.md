# RedoLog

目前主要使用的并发控制算法为OCC，是我根据内存数据库Hekaton改编来的。

其大概流程是在提交阶段写在Page上写Intent，然后写Commit日志提交，再修改Page上的Intent的Ts，使其成为有效的数据。

这里的问题就是一个事务所对应的在Page的修改分成了两个阶段，分别是写Intent，以及修改Intent的Ts。而其中修改Ts是在Commit之后执行的。说明这个操作不能失败。

最简单的方法是修改Ts不记录日志，单靠一个Commit日志做协调。这个是可行的，主流的内存数据库的方式都是这样。但是对于磁盘数据库来说，如果对于Page的修改不写日志，就有了额外的代价，比如lsn的推进需要一定的hack，以及无法并行恢复，必须串行恢复，也无法做到类似Aurora那样将Page的Redo下沉到存储层了。

所以这里我的解决方式是修改Ts会写日志。对于已经提交的事务，而修改Ts日志不全的情况下，会有一个Finalize的阶段，即帮助已经提交的事务将Redo写完。所以对于ARIES的修改是先做Redo，然后Finalize来完成所有已经Commit事务的Redo，再做Undo。